<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP Revision Game</title>
    <link rel="stylesheet" href="../css/style4.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <header>
            <h3>ESP Revision Game</h3>
        </header>
         <a href="../module8/lesson-five.html" class="back-to-lesson-btn">Back to lesson</a>

        
        <div class="game-info">
            <div><i class="fas fa-star"></i> Score: <span id="score-value">0</span></div>
            <div><i class="fas fa-clock"></i> Time: <span id="time-value">60</span>s</div>
        </div>
        
        <div class="game-container">
            <div class="mode-selector">
                <button class="mode-btn active" data-mode="mcq">Multiple Choice</button>
                <button class="mode-btn" data-mode="true-false">True/False</button>
            </div>
            
            <div class="progress-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            
            <div class="question-card">
                <div class="question" id="question-text">Loading question...</div>
                <div id="game-content">
                    <!-- Dynamic content will go here -->
                </div>
                <div class="feedback" id="feedback"></div>
            </div>
            
            <div class="controls">
                <button class="btn next-btn" id="next-btn" disabled>Next Question</button>
                <button class="btn reset-btn" id="reset-btn">Reset Game</button>
            </div>
            

            

        </div>
        
        <footer>
            <p>ESP </p>
        </footer>
    </div>

    <script>
        // ===== QUESTION BANK =====
        const mcqQuestions =
        [
  {
    "question": "Which instrument is best for gathering information from a large number of learners quickly and anonymously?",
    "options": [
      "Interviews",
      "Observations",
      "Questionnaires",
      "Meetings"
    ],
    "correct": 2,
    "feedback": " Questionnaires are efficient, scalable, and provide anonymity—making them ideal for initial broad data collection in ESP needs analysis."
  },
  {
    "question": "What is a key disadvantage of using questionnaires in needs analysis?",
    "options": [
      "They are too expensive to print",
      "They do not allow for spontaneous responses or clarification of unclear answers",
      "They require video equipment",
      "They can only be used with advanced learners"
    ],
    "correct": 1,
    "feedback": " Unlike interviews, questionnaires are static—researchers cannot ask follow-up questions if a response is vague or misunderstood."
  },
  {
    "question": "Why might an ESP practitioner choose interviews over questionnaires?",
    "options": [
      "To save time and reduce workload",
      "To collect superficial data from many people",
      "To explore learners’ needs in depth and clarify responses in real time",
      "To avoid direct contact with learners"
    ],
    "correct": 2,
    "feedback": " Interviews enable probing, explanation, and deeper insight—essential when investigating complex communication needs in professional contexts."
  },
  {
    "question": "Which instrument provides objective data on learners’ current language proficiency and specific weaknesses?",
    "options": [
      "Meetings",
      "Existing documentation",
      "Tests",
      "Questionnaires"
    ],
    "correct": 2,
    "feedback": " Tests offer measurable evidence of general ability and pinpoint linguistic problem areas—supporting diagnostic needs analysis."
  },
  {
    "question": "What is a major advantage of using observations in needs analysis?",
    "options": [
      "They rely solely on self-reported data",
      "They capture actual language use and behaviors as they occur",
      "They are the fastest method available",
      "They require no planning or training"
    ],
    "correct": 1,
    "feedback": " Observations provide authentic, real-time data on how learners use language in tasks—revealing patterns that surveys might miss."
  },
  {
    "question": "Which method is most effective for aligning the expectations of teachers, employers, and curriculum designers in ESP?",
    "options": [
      "Questionnaires",
      "Interviews",
      "Meetings",
      "Tests"
    ],
    "correct": 2,
    "feedback": " Meetings facilitate dialogue and consensus among diverse stakeholders—crucial in ESP where 'needs' are defined by both academic and professional communities."
  },
  {
    "question": "What is a potential risk associated with interviews in needs analysis?",
    "options": [
      "Too much respondent anonymity",
      "Interviewer bias and lack of standardization",
      "Inability to record responses",
      "Excessive speed of data collection"
    ],
    "correct": 1,
    "feedback": " Interviewer bias (e.g., leading questions) and inconsistency across interviewers can compromise data reliability—requiring careful training."
  },
  {
    "question": "Which of the following is considered 'existing information' in needs analysis?",
    "options": [
      "Responses to a newly designed survey",
      "Live classroom observations",
      "Previous course evaluations or institutional records",
      "Transcripts from new interviews"
    ],
    "correct": 2,
    "feedback": " Reviewing past data—such as student feedback, test results, or job requirement documents—provides valuable baseline insights without new data collection."
  },
  {
    "question": "Which disadvantage is specific to questionnaires compared to interviews?",
    "options": [
      "High cost per respondent",
      "Respondents may consult with one another before answering",
      "Requires audio recording",
      "Produces too much qualitative depth"
    ],
    "correct": 1,
    "feedback": " In group settings, learners may discuss answers, reducing individual authenticity—a risk not present in one-on-one interviews."
  },
  {
    "question": "Which instrument would best help an ESP teacher understand why medical students struggle with patient consultations?",
    "options": [
      "A grammar test only",
      "A multiple-choice questionnaire only",
      "Semi-structured interviews with the students",
      "Reviewing only the syllabus"
    ],
    "correct": 2,
    "feedback": " Interviews allow students to explain their anxieties, knowledge gaps, and real-world challenges—revealing needs that standardized tools might overlook."
  }
]















        const trueFalseQuestions = 
        [
  {
    "question": "Questionnaires are less time and energy consuming to administer compared to interviews.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " One key advantage of questionnaires is that they require less time and energy to administer, especially when collecting data from large groups of learners."
  },
  {
    "question": "A major disadvantage of questionnaires is that they allow researchers to clarify ambiguous responses during data collection.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " Questionnaires **do not allow** for clarification of issues—this is a key disadvantage, as respondents may misinterpret questions without opportunity for explanation."
  },
  {
    "question": "Interviews are more useful than questionnaires for collecting in-depth information about learners' needs.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " Interviews allow for deeper exploration, probing, and real-time clarification, making them ideal for understanding complex or nuanced learner needs."
  },
  {
    "question": "The quality of interview data is independent of the interviewer’s skills and experience.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " A key disadvantage of interviews is that data quality **depends heavily on interviewer skills**—poorly trained interviewers may introduce bias or miss critical insights."
  },
  {
    "question": "Tests can provide useful information about learners’ general ability levels and specific language problems in needs analysis.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " Tests are a valid instrument in needs analysis, offering objective data on proficiency and pinpointing linguistic weaknesses."
  },
  {
    "question": "Observations in needs analysis involve watching students and recording their actual behaviors in real-time.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " Observation is a direct method where practitioners watch and document learners’ language use, participation, and interaction patterns."
  },
  {
    "question": "Meetings are not useful in ESP needs analysis because they only involve teachers.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " Meetings are **useful for reaching consensus among stakeholders**—including teachers, employers, administrators, and learners—ensuring the course meets real-world demands."
  },
  {
    "question": "One advantage of questionnaires is that they offer greater anonymity to respondents, which may encourage honest answers.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " Anonymity in questionnaires can reduce social pressure and lead to more candid responses about language difficulties or attitudes."
  },
  {
    "question": "Existing information, such as previous records and documentation, can be reviewed as part of the needs analysis process.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " Analyzing existing data—like past course evaluations, placement test results, or institutional reports—is a practical and efficient needs analysis method."
  },
  {
    "question": "Interviews are highly standardized and produce identical results regardless of who conducts them.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " Interviews are **less standardized across different interviewers**, which can affect reliability and comparability of responses."
  }
]

        
         // ===== GAME STATE =====
        let currentQuestionIndex = 0;
        let score = 0;
        let gameMode = 'mcq';
        let timer;
        let timeLeft = 60;
        let answered = false;
        let selectedOption = null;
        let currentQuestions = [];

        // DOM elements
        const questionText = document.getElementById('question-text');
        const gameContent = document.getElementById('game-content');
        const feedbackElement = document.getElementById('feedback');
        const nextBtn = document.getElementById('next-btn');
        const resetBtn = document.getElementById('reset-btn');
        const scoreValue = document.getElementById('score-value');
        const timeValue = document.getElementById('time-value');
        const progressBar = document.getElementById('progress-bar');
        const modeBtns = document.querySelectorAll('.mode-btn');
        const mistakesSection = document.getElementById('mistakes-section');

        // Shuffle array function (Fisher-Yates algorithm)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Select random subset of questions
        function getRandomQuestions(questions, count = null) {
            const shuffled = shuffleArray(questions);
            if (count && count < questions.length) {
                return shuffled.slice(0, count);
            }
            return shuffled;
        }

        // Get current question set (randomized)
        function getCurrentQuestionSet() {
            if (gameMode === 'mcq') return getRandomQuestions(mcqQuestions, 3);
            if (gameMode === 'true-false') return getRandomQuestions(trueFalseQuestions, 3);
            return [];
        }

        // Initialize game
        function initGame() {
            currentQuestionIndex = 0;
            score = 0;
            timeLeft = 60;
            answered = false;
            selectedOption = null;
            
            // Get randomized questions for this session
            currentQuestions = getCurrentQuestionSet();
            
            scoreValue.textContent = score;
            timeValue.textContent = timeLeft;
            updateProgressBar();
            showQuestion();
            startTimer();
            mistakesSection.classList.remove('show');
            nextBtn.disabled = true;
        }

        // Start timer
        function startTimer() {
            clearInterval(timer);
            timer = setInterval(() => {
                timeLeft--;
                timeValue.textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    if (!answered) {
                        handleTimeUp();
                    }
                }
            }, 1000);
        }

        // Handle time up
        function handleTimeUp() {
            answered = true;
            feedbackElement.innerHTML = `<i class="fas fa-hourglass-end" style="color: var(--warning);"></i> Time's up!`;
            feedbackElement.className = "feedback show";
            nextBtn.disabled = false;
        }

        // Update progress bar
        function updateProgressBar() {
            const progress = ((currentQuestionIndex) / currentQuestions.length) * 100;
            progressBar.style.width = `${progress}%`;
        }

        // Show current question based on mode
        function showQuestion() {
            if (currentQuestionIndex >= currentQuestions.length) {
                endGame();
                return;
            }
            
            const q = currentQuestions[currentQuestionIndex];
            questionText.textContent = q.question;
            feedbackElement.className = 'feedback';
            gameContent.innerHTML = '';
            answered = false;
            nextBtn.disabled = true;
            
            renderMCQ(q);
        }

        // Render MCQ/True-False
        function renderMCQ(q) {
            const optionsContainer = document.createElement('div');
            optionsContainer.className = 'answer-options';
            
            // For MCQ, shuffle options but keep track of correct answer
            let displayOptions = [...q.options];
            let correctIndex = q.correct;
            
            if (gameMode === 'mcq') {
                // Create a copy with indices
                let indexedOptions = q.options.map((opt, i) => ({text: opt, originalIndex: i}));
                // Shuffle
                indexedOptions = shuffleArray(indexedOptions);
                // Update display
                displayOptions = indexedOptions.map(item => item.text);
                correctIndex = indexedOptions.findIndex(item => item.originalIndex === q.correct);
            }
            
            displayOptions.forEach((option, index) => {
                const optionEl = document.createElement('div');
                optionEl.className = 'option';
                optionEl.textContent = option;
                optionEl.addEventListener('click', () => selectMCQOption(index, correctIndex, q));
                optionsContainer.appendChild(optionEl);
            });
            
            gameContent.appendChild(optionsContainer);
        }

        // Handle MCQ option selection
        function selectMCQOption(selectedIndex, correctIndex, q) {
            if (answered) return;
            
            answered = true;
            clearInterval(timer);
            
            const options = gameContent.querySelectorAll('.option');
            options.forEach((opt, i) => {
                if (i === selectedIndex) {
                    opt.classList.add(selectedIndex === correctIndex ? 'correct' : 'incorrect');
                }
                if (i === correctIndex) {
                    opt.classList.add('correct');
                }
            });
            
            if (selectedIndex === correctIndex) {
                    score++;
                    scoreValue.textContent = score;
                    feedbackElement.innerHTML = `<i class="fas fa-check-circle" style="color: var(--success);"></i> Correct! ${q.feedback}`;
                } else {
                    feedbackElement.innerHTML = `<i class="fas fa-times-circle" style="color: var(--accent);"></i> Incorrect. ${q.feedback}`;
                }
            feedbackElement.className = 'feedback show';
            nextBtn.disabled = false;
            
            if (currentQuestionIndex === 0) {
                setTimeout(() => {
                    mistakesSection.classList.add('show');
                }, 1500);
            }
        }

        // Move to next question or end game
        function nextQuestion() {
            currentQuestionIndex++;
            
            if (currentQuestionIndex < currentQuestions.length) {
                timeLeft = 60;
                timeValue.textContent = timeLeft;
                showQuestion();
                startTimer();
            } else {
                endGame();
            }
            
            updateProgressBar();
        }

        // End game
        function endGame() {
            questionText.textContent = `Game Completed! Your final score is ${score}/${currentQuestions.length}`;
            gameContent.innerHTML = '';
            feedbackElement.innerHTML = `<i class="fas fa-trophy" style="color: var(--success);"></i> Great job! You completed ${currentQuestions.length} random questions. Review the revision checklist above.`;
            feedbackElement.className = 'feedback show';
            nextBtn.disabled = true;
            clearInterval(timer);
        }

        // Event listeners
        nextBtn.addEventListener('click', nextQuestion);
        resetBtn.addEventListener('click', initGame);
        
        modeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                modeBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameMode = btn.dataset.mode;
                initGame();
            });
        });

        // Initialize
        window.addEventListener('load', initGame);
    </script>
</body>
</html>       

        
