<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP Revision Game</title>
    <link rel="stylesheet" href="../css/style4.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <header>
            <h3>ESP Revision Game</h3>
        </header>
         <a href="../module8/lesson-one.html" class="back-to-lesson-btn">Back to lesson</a>

        
        <div class="game-info">
            <div><i class="fas fa-star"></i> Score: <span id="score-value">0</span></div>
            <div><i class="fas fa-clock"></i> Time: <span id="time-value">60</span>s</div>
        </div>
        
        <div class="game-container">
            <div class="mode-selector">
                <button class="mode-btn active" data-mode="mcq">Multiple Choice</button>
                <button class="mode-btn" data-mode="true-false">True/False</button>
            </div>
            
            <div class="progress-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            
            <div class="question-card">
                <div class="question" id="question-text">Loading question...</div>
                <div id="game-content">
                    <!-- Dynamic content will go here -->
                </div>
                <div class="feedback" id="feedback"></div>
            </div>
            
            <div class="controls">
                <button class="btn next-btn" id="next-btn" disabled>Next Question</button>
                <button class="btn reset-btn" id="reset-btn">Reset Game</button>
            </div>
            

            

        </div>
        
        <footer>
            <p>ESP</p>
        </footer>
    </div>

    <script>
        // ===== QUESTION BANK =====
        const mcqQuestions =
        [
  {
    "question": "What is the primary purpose of needs analysis in ESP?",
    "options": [
      "To replace general English teaching entirely",
      "To systematically study learners’ language needs, goals, and usage context to inform course design",
      "To assess teachers’ linguistic competence",
      "To translate textbooks into learners’ native languages"
    ],
    "correct": 1,
    "feedback": " Needs analysis ensures ESP courses are **tailored** to the specific communication demands of learners’ professional or academic fields."
  },
  {
    "question": "According to Escorcia (1985), what role does needs analysis play in ESP?",
    "options": [
      "It is an optional add-on",
      "It is the 'dynamic impulse' and 'driving force' behind course design",
      "It only applies to beginner learners",
      "It replaces the need for materials development"
    ],
    "correct": 1,
    "feedback": " Escorcia called it the justification for the 'S' and 'P' in ESP—the core engine of purpose-driven course creation."
  },
  {
    "question": "How does ESP benefit from needs analysis compared to EGP (English for General Purposes)?",
    "options": [
      "ESP ignores learner needs",
      "EGP is more specialized than ESP",
      "ESP uses needs analysis to focus on specific, real-world communication needs",
      "EGP conducts deeper needs analysis"
    ],
    "correct": 2,
    "feedback": " ESP’s strength is its **targeted approach**—needs analysis ensures relevance to learners’ actual tasks, unlike EGP’s broader focus."
  },
  {
    "question": "When should needs assessment be conducted in an ESP course?",
    "options": [
      "Only at the end of the course",
      "Only once, before the course begins",
      "Ongoing throughout the course",
      "Never—it’s unnecessary"
    ],
    "correct": 2,
    "feedback": " Ongoing assessment allows teachers to adapt content as learners progress or as professional demands evolve."
  },
  {
    "question": "What does a needs analysis questionnaire typically help ESP practitioners gather?",
    "options": [
      "Learners’ favorite colors",
      "Data on learners’ goals, challenges, and language use contexts",
      "Teacher salary information",
      "Historical grammar rules"
    ],
    "correct": 1,
    "feedback": " Questionnaires are practical tools to collect **learner-centered data** for informed course design."
  },
  {
    "question": "What is a key insight about the role of needs analysis in ESP?",
    "options": [
      "It makes courses longer",
      "It bridges the gap between general proficiency and specific professional/academic language needs",
      "It eliminates the need for speaking practice",
      "It focuses only on writing skills"
    ],
    "correct": 1,
    "feedback": " Needs analysis ensures learners acquire the **right skills** for their field—not just general fluency."
  },
  {
    "question": "What should be the starting point of sound ESP course design?",
    "options": [
      "Available textbooks",
      "Teacher’s favorite topics",
      "A profile of the learners’ needs",
      "Government curriculum mandates"
    ],
    "correct": 2,
    "feedback": " As the lesson states: 'fit what is taught to what is needed'—learner needs come first."
  },
  {
    "question": "Which of the following is a likely outcome of effective needs analysis in ESP?",
    "options": [
      "Generic lessons suitable for any learner",
      "Materials focused only on literature",
      "A course tailored to engineers’ technical report writing needs",
      "Elimination of all grammar instruction"
    ],
    "correct": 2,
    "feedback": " ESP courses become **highly relevant**—e.g., teaching nurses how to explain procedures or engineers how to write specifications."
  },
  {
    "question": "What does ESP stand for in the context of needs analysis?",
    "options": [
      "English for Simple Proficiency",
      "English for Special Purposes",
      "English for Standardized Pedagogy",
      "English for Spoken Practice"
    ],
    "correct": 1,
    "feedback": " ESP = English for **Special** (or Specific) **Purposes**—with needs analysis justifying both the 'S' and the 'P.'"
  },
  {
    "question": "Why is needs analysis considered foundational in ESP?",
    "options": [
      "It reduces teacher workload",
      "It ensures the course addresses real communication tasks in learners’ target contexts",
      "It replaces student assessment",
      "It focuses only on vocabulary lists"
    ],
    "correct": 1,
    "feedback": " Without needs analysis, ESP would lose its purpose—**relevance to authentic professional or academic language use**."
  }
]















        const trueFalseQuestions = 
        [
  {
    "question": "Needs analysis in ESP is a systematic study of learners’ language needs, goals, and the context of English use.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " Needs analysis in ESP involves a comprehensive investigation of what learners need to do with English in their specific professional or academic contexts."
  },
  {
    "question": "ESP has no advantage over EGP when it comes to needs analysis.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " ESP has a clear advantage: it centers course design on **needs analysis**, ensuring relevance to learners’ real-world tasks—unlike general English (EGP)."
  },
  {
    "question": "According to Escorcia (1985), needs analysis is the 'dynamic impulse' and 'driving force' behind ESP course design.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " Escorcia emphasized that needs analysis justifies the 'S' (Special) and 'P' (Purpose) in ESP and motivates course designers worldwide."
  },
  {
    "question": "Needs analysis is only conducted once at the beginning of an ESP course and never revisited.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " The lesson states that **ongoing needs assessment** throughout the course is important to ensure continued relevance and responsiveness to learner progress."
  },
  {
    "question": "The goal of needs analysis is to bridge the gap between general English proficiency and the specific language skills required in professional or academic settings.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " This is a key insight: ESP uses needs analysis to move beyond general fluency to **context-specific competence**."
  },
  {
    "question": "Needs analysis ensures that ESP courses are generic and suitable for all learners regardless of field.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " ESP courses are **tailored** to specific learner needs—e.g., medical English for doctors, legal English for lawyers—based on needs analysis."
  },
  {
    "question": "A needs analysis questionnaire is a practical instrument used in ESP course development.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " Questionnaires are common tools to gather data on learners’ goals, challenges, and language use contexts."
  },
  {
    "question": "Course design in ESP should start with textbook selection, not learner needs.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " A sound approach starts with a **profile of learner needs**—ensuring that 'what is taught' matches 'what is needed.'"
  },
  {
    "question": "Needs analysis in ESP considers only grammar gaps, not communication tasks or professional contexts.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " It examines the **full context** of language use—including tasks, genres, vocabulary, and communicative purposes in real-world settings."
  },
  {
    "question": "Needs analysis helps ESP practitioners design courses that prepare learners for success in their specific professional or academic fields.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " By identifying precise language demands, needs analysis ensures ESP courses build **relevant skills and competencies** for target contexts."
  }
]

        
         // ===== GAME STATE =====
        let currentQuestionIndex = 0;
        let score = 0;
        let gameMode = 'mcq';
        let timer;
        let timeLeft = 60;
        let answered = false;
        let selectedOption = null;
        let currentQuestions = [];

        // DOM elements
        const questionText = document.getElementById('question-text');
        const gameContent = document.getElementById('game-content');
        const feedbackElement = document.getElementById('feedback');
        const nextBtn = document.getElementById('next-btn');
        const resetBtn = document.getElementById('reset-btn');
        const scoreValue = document.getElementById('score-value');
        const timeValue = document.getElementById('time-value');
        const progressBar = document.getElementById('progress-bar');
        const modeBtns = document.querySelectorAll('.mode-btn');
        const mistakesSection = document.getElementById('mistakes-section');

        // Shuffle array function (Fisher-Yates algorithm)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Select random subset of questions
        function getRandomQuestions(questions, count = null) {
            const shuffled = shuffleArray(questions);
            if (count && count < questions.length) {
                return shuffled.slice(0, count);
            }
            return shuffled;
        }

        // Get current question set (randomized)
        function getCurrentQuestionSet() {
            if (gameMode === 'mcq') return getRandomQuestions(mcqQuestions, 3);
            if (gameMode === 'true-false') return getRandomQuestions(trueFalseQuestions, 3);
            return [];
        }

        // Initialize game
        function initGame() {
            currentQuestionIndex = 0;
            score = 0;
            timeLeft = 60;
            answered = false;
            selectedOption = null;
            
            // Get randomized questions for this session
            currentQuestions = getCurrentQuestionSet();
            
            scoreValue.textContent = score;
            timeValue.textContent = timeLeft;
            updateProgressBar();
            showQuestion();
            startTimer();
            mistakesSection.classList.remove('show');
            nextBtn.disabled = true;
        }

        // Start timer
        function startTimer() {
            clearInterval(timer);
            timer = setInterval(() => {
                timeLeft--;
                timeValue.textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    if (!answered) {
                        handleTimeUp();
                    }
                }
            }, 1000);
        }

        // Handle time up
        function handleTimeUp() {
            answered = true;
            feedbackElement.innerHTML = `<i class="fas fa-hourglass-end" style="color: var(--warning);"></i> Time's up!`;
            feedbackElement.className = "feedback show";
            nextBtn.disabled = false;
        }

        // Update progress bar
        function updateProgressBar() {
            const progress = ((currentQuestionIndex) / currentQuestions.length) * 100;
            progressBar.style.width = `${progress}%`;
        }

        // Show current question based on mode
        function showQuestion() {
            if (currentQuestionIndex >= currentQuestions.length) {
                endGame();
                return;
            }
            
            const q = currentQuestions[currentQuestionIndex];
            questionText.textContent = q.question;
            feedbackElement.className = 'feedback';
            gameContent.innerHTML = '';
            answered = false;
            nextBtn.disabled = true;
            
            renderMCQ(q);
        }

        // Render MCQ/True-False
        function renderMCQ(q) {
            const optionsContainer = document.createElement('div');
            optionsContainer.className = 'answer-options';
            
            // For MCQ, shuffle options but keep track of correct answer
            let displayOptions = [...q.options];
            let correctIndex = q.correct;
            
            if (gameMode === 'mcq') {
                // Create a copy with indices
                let indexedOptions = q.options.map((opt, i) => ({text: opt, originalIndex: i}));
                // Shuffle
                indexedOptions = shuffleArray(indexedOptions);
                // Update display
                displayOptions = indexedOptions.map(item => item.text);
                correctIndex = indexedOptions.findIndex(item => item.originalIndex === q.correct);
            }
            
            displayOptions.forEach((option, index) => {
                const optionEl = document.createElement('div');
                optionEl.className = 'option';
                optionEl.textContent = option;
                optionEl.addEventListener('click', () => selectMCQOption(index, correctIndex, q));
                optionsContainer.appendChild(optionEl);
            });
            
            gameContent.appendChild(optionsContainer);
        }

        // Handle MCQ option selection
        function selectMCQOption(selectedIndex, correctIndex, q) {
            if (answered) return;
            
            answered = true;
            clearInterval(timer);
            
            const options = gameContent.querySelectorAll('.option');
            options.forEach((opt, i) => {
                if (i === selectedIndex) {
                    opt.classList.add(selectedIndex === correctIndex ? 'correct' : 'incorrect');
                }
                if (i === correctIndex) {
                    opt.classList.add('correct');
                }
            });
            
            if (selectedIndex === correctIndex) {
                    score++;
                    scoreValue.textContent = score;
                    feedbackElement.innerHTML = `<i class="fas fa-check-circle" style="color: var(--success);"></i> Correct! ${q.feedback}`;
                } else {
                    feedbackElement.innerHTML = `<i class="fas fa-times-circle" style="color: var(--accent);"></i> Incorrect. ${q.feedback}`;
                }
            feedbackElement.className = 'feedback show';
            nextBtn.disabled = false;
            
            if (currentQuestionIndex === 0) {
                setTimeout(() => {
                    mistakesSection.classList.add('show');
                }, 1500);
            }
        }

        // Move to next question or end game
        function nextQuestion() {
            currentQuestionIndex++;
            
            if (currentQuestionIndex < currentQuestions.length) {
                timeLeft = 60;
                timeValue.textContent = timeLeft;
                showQuestion();
                startTimer();
            } else {
                endGame();
            }
            
            updateProgressBar();
        }

        // End game
        function endGame() {
            questionText.textContent = `Game Completed! Your final score is ${score}/${currentQuestions.length}`;
            gameContent.innerHTML = '';
            feedbackElement.innerHTML = `<i class="fas fa-trophy" style="color: var(--success);"></i> Great job! You completed ${currentQuestions.length} random questions. Review the revision checklist above.`;
            feedbackElement.className = 'feedback show';
            nextBtn.disabled = true;
            clearInterval(timer);
        }

        // Event listeners
        nextBtn.addEventListener('click', nextQuestion);
        resetBtn.addEventListener('click', initGame);
        
        modeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                modeBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameMode = btn.dataset.mode;
                initGame();
            });
        });

        // Initialize
        window.addEventListener('load', initGame);
    </script>
</body>
</html>       

        
