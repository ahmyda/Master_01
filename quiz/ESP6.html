<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP Revision Game</title>
    <link rel="stylesheet" href="../css/style4.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <header>
            <h3>ESP Revision Game</h3>
        </header>
         <a href="../module8/lesson-six.html" class="back-to-lesson-btn">Back to lesson</a>

        
        <div class="game-info">
            <div><i class="fas fa-star"></i> Score: <span id="score-value">0</span></div>
            <div><i class="fas fa-clock"></i> Time: <span id="time-value">60</span>s</div>
        </div>
        
        <div class="game-container">
            <div class="mode-selector">
                <button class="mode-btn active" data-mode="mcq">Multiple Choice</button>
                <button class="mode-btn" data-mode="true-false">True/False</button>
            </div>
            
            <div class="progress-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            
            <div class="question-card">
                <div class="question" id="question-text">Loading question...</div>
                <div id="game-content">
                    <!-- Dynamic content will go here -->
                </div>
                <div class="feedback" id="feedback"></div>
            </div>
            
            <div class="controls">
                <button class="btn next-btn" id="next-btn" disabled>Next Question</button>
                <button class="btn reset-btn" id="reset-btn">Reset Game</button>
            </div>
            

            

        </div>
        
        <footer>
            <p>ESP</p>
        </footer>
    </div>

    <script>
        // ===== QUESTION BANK =====
        const mcqQuestions =
        [
  {
    "question": "According to Brown (1995), what is the first step in conducting a needs analysis?",
    "options": [
      "Administering questionnaires",
      "Making basic decisions about target group, audience, analysts, and resource group",
      "Analyzing test results",
      "Writing the final report"
    ],
    "correct": 1,
    "feedback": " Step 1 involves foundational planning: identifying who the learners are, who will use the findings, who will conduct the study, and who will provide data."
  },
  {
    "question": "Which of the following is NOT listed by Brown as a technique for gathering information in needs analysis?",
    "options": [
      "Tests",
      "Observations",
      "Social media polls",
      "Existing information"
    ],
    "correct": 2,
    "feedback": " Brown lists tests, observations, interviews, meetings, questionnaires, and existing information—but not informal methods like social media polls."
  },
  {
    "question": "What three criteria must be considered when using collected data in needs analysis?",
    "options": [
      "Cost, speed, popularity",
      "Reliability, validity, usability",
      "Length, color, font",
      "Teacher preference, student age, class size"
    ],
    "correct": 1,
    "feedback": " Data must be **reliable** (consistent), **valid** (accurate), and **usable** (practical) to inform sound course decisions."
  },
  {
    "question": "According to Jordan (1997), what should be the starting point for syllabus and materials development?",
    "options": [
      "Textbook availability",
      "Teacher experience",
      "Needs analysis",
      "Government mandates"
    ],
    "correct": 2,
    "feedback": " Jordan stated that 'needs analysis should be the starting point for devising syllabus, course materials and classroom activities.'"
  },
  {
    "question": "Which scholar emphasized that needs assessment helps 'draw up a profile to establish coherent objectives'?",
    "options": [
      "Berwick (1989)",
      "McDonough (1984)",
      "Riddell (1991)",
      "Brown (1995)"
    ],
    "correct": 1,
    "feedback": " McDonough (1984) highlighted that learner needs data enables the creation of a coherent instructional profile and clear objectives."
  },
  {
    "question": "What is a core ESP principle according to Hutchinson and Waters (1987)?",
    "options": [
      "Teach grammar first, always",
      "Use only native-speaking teachers",
      "Tell me what you need English for and I will tell you the English that you need",
      "Avoid needs analysis to save time"
    ],
    "correct": 2,
    "feedback": " This principle underscores ESP’s purpose-driven, learner-centered philosophy."
  },
  {
    "question": "Why is needs analysis considered a continuous process in ESP?",
    "options": [
      "To increase administrative paperwork",
      "To replace student assessment",
      "To adjust learning objectives as new needs arise during the course",
      "To delay course completion"
    ],
    "correct": 2,
    "feedback": " Ongoing analysis allows for **real-time adaptation**—ensuring the course evolves with learners’ changing needs and contexts."
  },
  {
    "question": "Who are the 'resource group' in Brown’s Step 1 of needs analysis?",
    "options": [
      "People who fund the course",
      "People who serve as sources of information",
      "The final learners of the course",
      "External examiners"
    ],
    "correct": 1,
    "feedback": " The resource group provides data—e.g., students, employers, alumni, or subject-matter experts—whose insights shape the analysis."
  },
  {
    "question": "What role does learner feedback play in ongoing needs analysis?",
    "options": [
      "It is ignored to maintain course stability",
      "It serves as a basis for modifying learning objectives",
      "It replaces all formal assessments",
      "It is only collected at the end of the course"
    ],
    "correct": 1,
    "feedback": " Feedback informs mid-course adjustments—making ESP responsive and learner-centered throughout the teaching cycle."
  },
  {
    "question": "At which stages does ESP emphasize the importance of needs analysis?",
    "options": [
      "Only at the beginning",
      "Only during materials selection",
      "Course designing, learning/teaching process, and application",
      "Only for accreditation purposes"
    ],
    "correct": 2,
    "feedback": " Needs analysis is integrated **throughout the entire ESP process**—from design to delivery to evaluation."
  }
]















        const trueFalseQuestions =
        [
  {
    "question": "According to Brown (1995), the first step in needs analysis involves making basic decisions about the target group, audience, analysts, and resource group.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " Step 1 requires defining who the learners are (target group), who will use the results (audience), who will conduct the analysis (analysts), and who will provide information (resource group)."
  },
  {
    "question": "Gathering information in needs analysis can only be done through questionnaires and interviews.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " Brown lists multiple techniques: tests, observations, interviews, meetings, questionnaires, and existing information—all valid for data collection."
  },
  {
    "question": "When using collected data, researchers must consider reliability, validity, and usability.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " These three criteria ensure the data is consistent (reliability), measures what it claims (validity), and is practical to implement (usability)."
  },
  {
    "question": "Berwick (1989) argued that needs assessment is unnecessary for course design decisions.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " Berwick stated that needs assessment is **important for decision planners** to design effective courses."
  },
  {
    "question": "McDonough (1984) believed that information about learners’ language needs helps establish coherent course objectives.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " McDonough emphasized that learner needs inform the creation of a clear profile, which guides objective-setting and content decisions."
  },
  {
    "question": "Riddell (1991) and Jordan (1997) both downplayed the role of needs analysis in syllabus and materials development.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " Riddell called it 'crucial,' and Jordan stated it should be the **starting point** for syllabus, materials, and classroom activities."
  },
  {
    "question": "A core principle of ESP is: 'Tell me what you need English for and I will tell you the English that you need.'",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " This quote from Hutchinson and Waters (1987) captures the essence of ESP: language teaching is driven by purpose and context."
  },
  {
    "question": "Needs analysis in ESP is only conducted once—at the beginning of course design.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " Needs analysis is a **continuous process**—it should be carried out throughout the course to adjust objectives based on learner feedback and emerging needs."
  },
  {
    "question": "Learner feedback can serve as a basis for modifying learning objectives during a course.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " Ongoing needs analysis uses feedback to realign objectives, content, and methods—ensuring the course remains relevant and responsive."
  },
  {
    "question": "ESP places little emphasis on needs analysis during the actual teaching and learning process.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " ESP emphasizes needs analysis **at every stage**: course design, teaching/learning process, and application—making it central to the entire cycle."
  }
] 

        
         // ===== GAME STATE =====
        let currentQuestionIndex = 0;
        let score = 0;
        let gameMode = 'mcq';
        let timer;
        let timeLeft = 60;
        let answered = false;
        let selectedOption = null;
        let currentQuestions = [];

        // DOM elements
        const questionText = document.getElementById('question-text');
        const gameContent = document.getElementById('game-content');
        const feedbackElement = document.getElementById('feedback');
        const nextBtn = document.getElementById('next-btn');
        const resetBtn = document.getElementById('reset-btn');
        const scoreValue = document.getElementById('score-value');
        const timeValue = document.getElementById('time-value');
        const progressBar = document.getElementById('progress-bar');
        const modeBtns = document.querySelectorAll('.mode-btn');
        const mistakesSection = document.getElementById('mistakes-section');

        // Shuffle array function (Fisher-Yates algorithm)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Select random subset of questions
        function getRandomQuestions(questions, count = null) {
            const shuffled = shuffleArray(questions);
            if (count && count < questions.length) {
                return shuffled.slice(0, count);
            }
            return shuffled;
        }

        // Get current question set (randomized)
        function getCurrentQuestionSet() {
            if (gameMode === 'mcq') return getRandomQuestions(mcqQuestions, 3);
            if (gameMode === 'true-false') return getRandomQuestions(trueFalseQuestions, 3);
            return [];
        }

        // Initialize game
        function initGame() {
            currentQuestionIndex = 0;
            score = 0;
            timeLeft = 60;
            answered = false;
            selectedOption = null;
            
            // Get randomized questions for this session
            currentQuestions = getCurrentQuestionSet();
            
            scoreValue.textContent = score;
            timeValue.textContent = timeLeft;
            updateProgressBar();
            showQuestion();
            startTimer();
            mistakesSection.classList.remove('show');
            nextBtn.disabled = true;
        }

        // Start timer
        function startTimer() {
            clearInterval(timer);
            timer = setInterval(() => {
                timeLeft--;
                timeValue.textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    if (!answered) {
                        handleTimeUp();
                    }
                }
            }, 1000);
        }

        // Handle time up
        function handleTimeUp() {
            answered = true;
            feedbackElement.innerHTML = `<i class="fas fa-hourglass-end" style="color: var(--warning);"></i> Time's up!`;
            feedbackElement.className = "feedback show";
            nextBtn.disabled = false;
        }

        // Update progress bar
        function updateProgressBar() {
            const progress = ((currentQuestionIndex) / currentQuestions.length) * 100;
            progressBar.style.width = `${progress}%`;
        }

        // Show current question based on mode
        function showQuestion() {
            if (currentQuestionIndex >= currentQuestions.length) {
                endGame();
                return;
            }
            
            const q = currentQuestions[currentQuestionIndex];
            questionText.textContent = q.question;
            feedbackElement.className = 'feedback';
            gameContent.innerHTML = '';
            answered = false;
            nextBtn.disabled = true;
            
            renderMCQ(q);
        }

        // Render MCQ/True-False
        function renderMCQ(q) {
            const optionsContainer = document.createElement('div');
            optionsContainer.className = 'answer-options';
            
            // For MCQ, shuffle options but keep track of correct answer
            let displayOptions = [...q.options];
            let correctIndex = q.correct;
            
            if (gameMode === 'mcq') {
                // Create a copy with indices
                let indexedOptions = q.options.map((opt, i) => ({text: opt, originalIndex: i}));
                // Shuffle
                indexedOptions = shuffleArray(indexedOptions);
                // Update display
                displayOptions = indexedOptions.map(item => item.text);
                correctIndex = indexedOptions.findIndex(item => item.originalIndex === q.correct);
            }
            
            displayOptions.forEach((option, index) => {
                const optionEl = document.createElement('div');
                optionEl.className = 'option';
                optionEl.textContent = option;
                optionEl.addEventListener('click', () => selectMCQOption(index, correctIndex, q));
                optionsContainer.appendChild(optionEl);
            });
            
            gameContent.appendChild(optionsContainer);
        }

        // Handle MCQ option selection
        function selectMCQOption(selectedIndex, correctIndex, q) {
            if (answered) return;
            
            answered = true;
            clearInterval(timer);
            
            const options = gameContent.querySelectorAll('.option');
            options.forEach((opt, i) => {
                if (i === selectedIndex) {
                    opt.classList.add(selectedIndex === correctIndex ? 'correct' : 'incorrect');
                }
                if (i === correctIndex) {
                    opt.classList.add('correct');
                }
            });
            
            if (selectedIndex === correctIndex) {
                    score++;
                    scoreValue.textContent = score;
                    feedbackElement.innerHTML = `<i class="fas fa-check-circle" style="color: var(--success);"></i> Correct! ${q.feedback}`;
                } else {
                    feedbackElement.innerHTML = `<i class="fas fa-times-circle" style="color: var(--accent);"></i> Incorrect. ${q.feedback}`;
                }
            feedbackElement.className = 'feedback show';
            nextBtn.disabled = false;
            
            if (currentQuestionIndex === 0) {
                setTimeout(() => {
                    mistakesSection.classList.add('show');
                }, 1500);
            }
        }

        // Move to next question or end game
        function nextQuestion() {
            currentQuestionIndex++;
            
            if (currentQuestionIndex < currentQuestions.length) {
                timeLeft = 60;
                timeValue.textContent = timeLeft;
                showQuestion();
                startTimer();
            } else {
                endGame();
            }
            
            updateProgressBar();
        }

        // End game
        function endGame() {
            questionText.textContent = `Game Completed! Your final score is ${score}/${currentQuestions.length}`;
            gameContent.innerHTML = '';
            feedbackElement.innerHTML = `<i class="fas fa-trophy" style="color: var(--success);"></i> Great job! You completed ${currentQuestions.length} random questions. Review the revision checklist above.`;
            feedbackElement.className = 'feedback show';
            nextBtn.disabled = true;
            clearInterval(timer);
        }

        // Event listeners
        nextBtn.addEventListener('click', nextQuestion);
        resetBtn.addEventListener('click', initGame);
        
        modeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                modeBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameMode = btn.dataset.mode;
                initGame();
            });
        });

        // Initialize
        window.addEventListener('load', initGame);
    </script>
</body>
</html>       

        
