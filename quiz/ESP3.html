<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP Revision Game</title>
    <link rel="stylesheet" href="../css/style4.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <header>
            <h3>ESP Revision Game</h3>
        </header>
         <a href="../module8/lesson-three.html" class="back-to-lesson-btn">Back to lesson</a>

        
        <div class="game-info">
            <div><i class="fas fa-star"></i> Score: <span id="score-value">0</span></div>
            <div><i class="fas fa-clock"></i> Time: <span id="time-value">60</span>s</div>
        </div>
        
        <div class="game-container">
            <div class="mode-selector">
                <button class="mode-btn active" data-mode="mcq">Multiple Choice</button>
                <button class="mode-btn" data-mode="true-false">True/False</button>
            </div>
            
            <div class="progress-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            
            <div class="question-card">
                <div class="question" id="question-text">Loading question...</div>
                <div id="game-content">
                    <!-- Dynamic content will go here -->
                </div>
                <div class="feedback" id="feedback"></div>
            </div>
            
            <div class="controls">
                <button class="btn next-btn" id="next-btn" disabled>Next Question</button>
                <button class="btn reset-btn" id="reset-btn">Reset Game</button>
            </div>
            

            

        </div>
        
        <footer>
            <p>ESP</p>
        </footer>
    </div>

    <script>
        // ===== QUESTION BANK =====
        const mcqQuestions =
        [
  {
    "question": "When did the term 'needs analysis' first appear, according to West (1994)?",
    "options": [
      "1940s",
      "1960s",
      "1920s",
      "1980s"
    ],
    "correct": 2,
    "feedback": " Though central to ESP in the 1960s, the term originated in the **1920s**—long before ESP emerged as a field."
  },
  {
    "question": "Who argued that awareness of learners’ needs distinguishes ESP from general English?",
    "options": [
      "Seedhouse (1995)",
      "Long (2005)",
      "Hutchinson and Waters (1987)",
      "West (1994)"
    ],
    "correct": 2,
    "feedback": " Hutchinson and Waters (1987) made this claim, though it was later contested by Seedhouse."
  },
  {
    "question": "What was Seedhouse’s (1995) stance on needs analysis in general English?",
    "options": [
      "It is unnecessary in all contexts",
      "It should be banned in EGP",
      "It is only useful for beginners",
      "It can and should be applied in general English courses"
    ],
    "correct": 3,
    "feedback": " Seedhouse rejected the idea that needs analysis is exclusive to ESP, advocating for its use in **all** language teaching contexts."
  },
  {
    "question": "According to Long (2005), what is a consequence of skipping needs analysis in course design?",
    "options": [
      "Faster course delivery",
      "More creative teaching",
      "Lack of detailed goals and insufficient academic support for learners",
      "Higher student satisfaction"
    ],
    "correct": 2,
    "feedback": " Long warned that without needs analysis, courses lack focus and fail to meet learners’ specific requirements within the given timeframe."
  },
  {
    "question": "What does Dudley-Evans and St. John’s ESP process model suggest about the timing of needs analysis?",
    "options": [
      "It must occur only before the course starts",
      "It is optional and rarely used",
      "It can be conducted at different stages of the course as needed",
      "It replaces assessment entirely"
    ],
    "correct": 2,
    "feedback": " Their model treats needs analysis as a **flexible, ongoing process**—not a one-off initial step."
  },
  {
    "question": "What can be a direct outcome of ongoing needs analysis in an ESP course?",
    "options": [
      "Elimination of all teachers",
      "Course re-alignment through revised objectives and modified materials",
      "Standardization of all student responses",
      "Reduction in course duration"
    ],
    "correct": 1,
    "feedback": " Ongoing analysis informs **re-alignment**—ensuring the course remains relevant and responsive to evolving learner needs."
  },
  {
    "question": "Which phase of ESP course development is NOT linked to needs analysis?",
    "options": [
      "Course design",
      "Materials selection",
      "Pedagogical approaches",
      "None of the above—all are linked"
    ],
    "correct": 3,
    "feedback": " Needs analysis informs **all** these phases—ensuring coherence and relevance across the entire course."
  },
  {
    "question": "Why is ongoing needs analysis justified in existing ESP courses?",
    "options": [
      "To increase tuition fees",
      "To replace student feedback",
      "To support successful revision and improvement of the programme",
      "To reduce teacher workload"
    ],
    "correct": 2,
    "feedback": " It provides evidence for updating content and methods, leading to more effective and adaptive ESP programmes."
  },
  {
    "question": "How do many ESP practitioners view needs analysis?",
    "options": [
      "As an outdated concept",
      "As optional for experienced teachers",
      "As fundamental to successful language course development",
      "As relevant only to writing courses"
    ],
    "correct": 2,
    "feedback": " It is widely regarded as **essential**—the foundation for learner-centered, purpose-driven ESP instruction."
  },
  {
    "question": "What might course re-alignment involve after an ongoing needs analysis?",
    "options": [
      "Changing the institution’s name",
      "Revising course objectives and modifying teaching materials",
      "Eliminating all assessments",
      "Switching to a different language"
    ],
    "correct": 1,
    "feedback": " Re-alignment means adjusting **objectives, content, and resources** based on fresh data about learner needs and challenges."
  }
]















        const trueFalseQuestions = 
        [
  {
    "question": "The term 'needs analysis' first appeared in the 1960s alongside the rise of ESP.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " While needs analysis became central to ESP in the 1960s, the term itself first appeared in the **1920s** (West, 1994)."
  },
  {
    "question": "Hutchinson and Waters (1987) argued that awareness of learners’ needs is what distinguishes ESP from general English.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " They claimed that this awareness is a key differentiator—though Seedhouse (1995) later challenged this view."
  },
  {
    "question": "Seedhouse (1995) agreed that only ESP uses needs analysis, not general English courses.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " Seedhouse **rejected** Hutchinson and Waters’ assumption, arguing that needs analysis **can and should** be applied in general English courses too."
  },
  {
    "question": "According to Long (2005), a language course without needs analysis fails to provide detailed, selective goals or adequate academic support.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " Long emphasized that needs analysis is essential for setting focused objectives and supporting learners effectively within the course timeframe."
  },
  {
    "question": "Needs analysis is only conducted once—at the very beginning of course development—and never revisited.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " Dudley-Evans and St. John’s model shows that needs analysis can and should be conducted **at different stages**, especially in ongoing or revised courses."
  },
  {
    "question": "Ongoing needs analysis can lead to successful revision of an ESP programme by informing course re-alignment.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " Findings from mid-course or post-course needs analysis can justify revising objectives, materials, and teaching approaches."
  },
  {
    "question": "Needs analysis is unrelated to assessment and evaluation in ESP course development.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " Needs analysis is directly linked to **assessment and evaluation**, as well as course design, materials selection, and pedagogical approaches."
  },
  {
    "question": "Many ESP practitioners consider needs analysis fundamental to successful language course development.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " It is widely acknowledged as a cornerstone of effective, learner-centered ESP course design."
  },
  {
    "question": "Dudley-Evans and St. John’s ESP process model suggests that needs analysis is a one-time, initial step only.",
    "options": ["True", "False"],
    "correct": 1,
    "feedback": " Their diagram illustrates that needs analysis is **iterative**—it can occur at multiple points depending on the situation and course stage."
  },
  {
    "question": "Course re-alignment based on ongoing needs analysis may involve modifying teaching methods and materials.",
    "options": ["True", "False"],
    "correct": 0,
    "feedback": " Re-alignment responds to new insights by adjusting objectives, content, and instructional strategies to better meet learner needs."
  }
]

        
         // ===== GAME STATE =====
        let currentQuestionIndex = 0;
        let score = 0;
        let gameMode = 'mcq';
        let timer;
        let timeLeft = 60;
        let answered = false;
        let selectedOption = null;
        let currentQuestions = [];

        // DOM elements
        const questionText = document.getElementById('question-text');
        const gameContent = document.getElementById('game-content');
        const feedbackElement = document.getElementById('feedback');
        const nextBtn = document.getElementById('next-btn');
        const resetBtn = document.getElementById('reset-btn');
        const scoreValue = document.getElementById('score-value');
        const timeValue = document.getElementById('time-value');
        const progressBar = document.getElementById('progress-bar');
        const modeBtns = document.querySelectorAll('.mode-btn');
        const mistakesSection = document.getElementById('mistakes-section');

        // Shuffle array function (Fisher-Yates algorithm)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Select random subset of questions
        function getRandomQuestions(questions, count = null) {
            const shuffled = shuffleArray(questions);
            if (count && count < questions.length) {
                return shuffled.slice(0, count);
            }
            return shuffled;
        }

        // Get current question set (randomized)
        function getCurrentQuestionSet() {
            if (gameMode === 'mcq') return getRandomQuestions(mcqQuestions, 3);
            if (gameMode === 'true-false') return getRandomQuestions(trueFalseQuestions, 3);
            return [];
        }

        // Initialize game
        function initGame() {
            currentQuestionIndex = 0;
            score = 0;
            timeLeft = 60;
            answered = false;
            selectedOption = null;
            
            // Get randomized questions for this session
            currentQuestions = getCurrentQuestionSet();
            
            scoreValue.textContent = score;
            timeValue.textContent = timeLeft;
            updateProgressBar();
            showQuestion();
            startTimer();
            mistakesSection.classList.remove('show');
            nextBtn.disabled = true;
        }

        // Start timer
        function startTimer() {
            clearInterval(timer);
            timer = setInterval(() => {
                timeLeft--;
                timeValue.textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    if (!answered) {
                        handleTimeUp();
                    }
                }
            }, 1000);
        }

        // Handle time up
        function handleTimeUp() {
            answered = true;
            feedbackElement.innerHTML = `<i class="fas fa-hourglass-end" style="color: var(--warning);"></i> Time's up!`;
            feedbackElement.className = "feedback show";
            nextBtn.disabled = false;
        }

        // Update progress bar
        function updateProgressBar() {
            const progress = ((currentQuestionIndex) / currentQuestions.length) * 100;
            progressBar.style.width = `${progress}%`;
        }

        // Show current question based on mode
        function showQuestion() {
            if (currentQuestionIndex >= currentQuestions.length) {
                endGame();
                return;
            }
            
            const q = currentQuestions[currentQuestionIndex];
            questionText.textContent = q.question;
            feedbackElement.className = 'feedback';
            gameContent.innerHTML = '';
            answered = false;
            nextBtn.disabled = true;
            
            renderMCQ(q);
        }

        // Render MCQ/True-False
        function renderMCQ(q) {
            const optionsContainer = document.createElement('div');
            optionsContainer.className = 'answer-options';
            
            // For MCQ, shuffle options but keep track of correct answer
            let displayOptions = [...q.options];
            let correctIndex = q.correct;
            
            if (gameMode === 'mcq') {
                // Create a copy with indices
                let indexedOptions = q.options.map((opt, i) => ({text: opt, originalIndex: i}));
                // Shuffle
                indexedOptions = shuffleArray(indexedOptions);
                // Update display
                displayOptions = indexedOptions.map(item => item.text);
                correctIndex = indexedOptions.findIndex(item => item.originalIndex === q.correct);
            }
            
            displayOptions.forEach((option, index) => {
                const optionEl = document.createElement('div');
                optionEl.className = 'option';
                optionEl.textContent = option;
                optionEl.addEventListener('click', () => selectMCQOption(index, correctIndex, q));
                optionsContainer.appendChild(optionEl);
            });
            
            gameContent.appendChild(optionsContainer);
        }

        // Handle MCQ option selection
        function selectMCQOption(selectedIndex, correctIndex, q) {
            if (answered) return;
            
            answered = true;
            clearInterval(timer);
            
            const options = gameContent.querySelectorAll('.option');
            options.forEach((opt, i) => {
                if (i === selectedIndex) {
                    opt.classList.add(selectedIndex === correctIndex ? 'correct' : 'incorrect');
                }
                if (i === correctIndex) {
                    opt.classList.add('correct');
                }
            });
            
            if (selectedIndex === correctIndex) {
                    score++;
                    scoreValue.textContent = score;
                    feedbackElement.innerHTML = `<i class="fas fa-check-circle" style="color: var(--success);"></i> Correct! ${q.feedback}`;
                } else {
                    feedbackElement.innerHTML = `<i class="fas fa-times-circle" style="color: var(--accent);"></i> Incorrect. ${q.feedback}`;
                }
            feedbackElement.className = 'feedback show';
            nextBtn.disabled = false;
            
            if (currentQuestionIndex === 0) {
                setTimeout(() => {
                    mistakesSection.classList.add('show');
                }, 1500);
            }
        }

        // Move to next question or end game
        function nextQuestion() {
            currentQuestionIndex++;
            
            if (currentQuestionIndex < currentQuestions.length) {
                timeLeft = 60;
                timeValue.textContent = timeLeft;
                showQuestion();
                startTimer();
            } else {
                endGame();
            }
            
            updateProgressBar();
        }

        // End game
        function endGame() {
            questionText.textContent = `Game Completed! Your final score is ${score}/${currentQuestions.length}`;
            gameContent.innerHTML = '';
            feedbackElement.innerHTML = `<i class="fas fa-trophy" style="color: var(--success);"></i> Great job! You completed ${currentQuestions.length} random questions. Review the revision checklist above.`;
            feedbackElement.className = 'feedback show';
            nextBtn.disabled = true;
            clearInterval(timer);
        }

        // Event listeners
        nextBtn.addEventListener('click', nextQuestion);
        resetBtn.addEventListener('click', initGame);
        
        modeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                modeBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameMode = btn.dataset.mode;
                initGame();
            });
        });

        // Initialize
        window.addEventListener('load', initGame);
    </script>
</body>
</html>       

        
